
Examples:
    
    action( :list, :get => [ :resources ] ) do
      action( :all ) and render( :list )
    end
    
    action( :read, :get => [ :resource, :name, { :mode => 'show' } ] ) do
      action( :find, name ) and render( mode )
    end
    
    action( :create, :post => [ :resources ] ) do
      redirect( paths.read( action( :create ).name, 'edit' ) )
    end
    
    action( :update, :put => [ :resource, :name ] ) do
      action( :update, name ) and redirect( paths.read( name ) )
    end
    
    action( :delete, :delete => [ :resource, :name ] ) do
      action( :delete, name )
    end

== Mappings

A mapping declaration
  may specify a resource in the options with a key of :resource or :resources
  uses app::Resources::Default when a resource has not been otherwise specified
  may be given a name, using a Symbol as its first argument
  can be anonymous, in which case an action block is required
  
  specifies the path to match using the HTTP method as the key and an Array as the value
    each item in the Array corresponds to a URL component
    symbols are matched against a default Regexp
      these matches become named parameters
    unless a custom Regexp is supplied. ???
      action( :show, :get => [ :resources, { :name => /\w+/ } ] ) { path( resource, name ) }
    strings match exact strings
    regexps can be substituted, but their matches are not saved as named parameters. 
    hashes denote optional arguments, where the key is the parameter and the value is the default
      Obviously, this will only really work for optional arguments at the end of the path. ???
  
  can match on the Accepts header (and others?) using additional hash pairs (:accepts => 'Nothing')
  can match against the host name using a key of :domain with a String value
  can match against the url scheme using a key of :scheme with a String value
  
  defines a path generator method on its resource's "shadow" Paths object
  
  may take a block, which is used as the mapping's action
  defines a method on the Resource, using the mapping's name as the method name
  will call the Resource method with the mapping's name if no block is given



An exception handler
  is defined using Mapping#handle
  uses the Error resource by default
  can take the same constraints as an action
  ( can it take a name?  would that be useful in any way? )
  

:before, :after, :wrap, and :during filters
  take the same constraints as actions
  are defined using methods of the appropriate name


Mapping#with(options, &block) 
  specifies options to be used for mappings done in a block

== Resources

A Resource object
  has a "shadow" Paths object
  can access its Paths object using Resource#paths or Resource.paths (see the #create mapping rule)


A Paths object 
  has path generating methods created by mappings
  has a class hierarchy mirroring its Resource's ancestry
  has heritable generator methods
  path generators honor the optional arguments supplied as a Hash, using defaults if not supplied


The Default resource defines these methods

  #action calls your controller for you with the given method and arguments.
  #render does the same thing for your view. 
  #redirect takes a string (probably generated by the Paths object) for the location
  Parameters can be accessed as local methods using #method_missing.
  #view and #controller take blocks to run in the view or controller scope
    All the necessary parameter passing is handled for you (investigate)
  #resources and #resource have seamless bi-directional inflection.
  
  

== Misc

RFE:  We will also add regexp matching to constraints (like the domain) in the very near future.

In the dispatcher:

actions
  first match wins

handlers
  first match wins

filters
  all matches run
